/*
    Initial author: Convery (tcn@ayria.se)
    Started: 2020-10-14
    License: MIT
*/

#include <Stdinclude.hpp>
#include <Global.hpp>

namespace Social
{
    std::vector<Userinfo_t> Friends{};

    void removeFriend(uint32_t UserID)
    {
        const Userinfo_t Friend{ UserID, Username.data() };
        std::erase_if(Friends, [&](const auto &Item) { return Item.UserID == Friend.UserID; });

        const auto Filebuffer = "// This file was generated by Ayria_cpp.\n"s + Friendslist(nullptr);
        FS::Writefile("./Ayria/Friendslist.json", Filebuffer);
    }
    void addFriend(uint32_t UserID, std::string_view Username)
    {
        const Userinfo_t Friend{ UserID, Username.data() };
        std::erase_if(Friends, [&](const auto &Item) { return Item.UserID == Friend.UserID; });
        Friends.emplace_back(std::move(Friend));

        const auto Filebuffer = "// This file was generated by Ayria_cpp.\n"s + Friendslist(nullptr);
        FS::Writefile("./Ayria/Friendslist.json", Filebuffer);
    }
    const std::vector<Userinfo_t> *getFriendslist()
    {
        // Load from disk.
        if (Friends.empty())
        {
            if (const auto &Filebuffer = FS::Readfile("./Ayria/Friendslist.json"); !Filebuffer.empty())
            {
                const auto Array = ParseJSON(B2S(Filebuffer));
                if (Array.is_array())
                {
                    for (const auto &Object : Array)
                    {
                        if (!Object.contains("Username") || !Object.contains("UserID")) continue;
                        const Userinfo_t Friend{ Object["UserID"], Object["Username"] };

                        std::erase_if(Friends, [&](const auto &Item) { return Item.UserID == Friend.UserID; });
                        Friends.emplace_back(std::move(Friend));
                    }
                }
                else Errorprint("./Ayria/Friendslist.json is not an array of objects");
            }
        }

        // TODO(tcn): Poll a server?
        return &Friends;
    }
}
